## Copyright (C) 2019 Jeremiah Orians
## This file is part of stage0.
##
## stage0 is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## stage0 is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with stage0.  If not, see <http://www.gnu.org/licenses/>.


## ELF Header
#:ELF_base
7F 45 4C 46                     # e_ident[EI_MAG0-3] ELF's magic number

01                              # e_ident[EI_CLASS] Indicating 32 bit
01                              # e_ident[EI_DATA] Indicating little endianness
01                              # e_ident[EI_VERSION] Indicating original elf

03                              # e_ident[EI_OSABI] Set at 3 because FreeBSD is strict
00                              # e_ident[EI_ABIVERSION] Set at 0 because no one cares

00 00 00 00 00 00 00            # e_ident[EI_PAD]

02 00                           # e_type Indicating Executable
03 00                           # e_machine Indicating x86
01 00 00 00                     # e_version Indicating original elf

54 80 04 08                     # e_entry Address of the entry point
34 00 00 00                     # e_phoff Address of program header table
00 00 00 00                     # e_shoff Address of section header table

00 00 00 00                     # e_flags

34 00                           # e_ehsize Indicating our 52 Byte header

20 00                           # e_phentsize size of a program header table
01 00                           # e_phnum number of entries in program table

00 00                           # e_shentsize size of a section header table
00 00                           # e_shnum number of entries in section table

00 00                           # e_shstrndx index of the section names

## Program Header
#:ELF_program_headers
#:ELF_program_header__text
01 00 00 00                     # ph_type: PT-LOAD = 1
00 00 00 00                     # ph_offset

00 80 04 08                     # ph_vaddr
00 80 04 08                     # ph_physaddr

27 01 00 00                     # ph_filesz
27 01 00 00                     # ph_memsz

07 00 00 00                     # ph_flags: PF-X|PF-W|PF-R = 7
01 00 00 00                     # ph_align

#:ELF_text

; Where the ELF Header is going to hit
; Simply jump to _start
; Our main function
# :_start ; (0x8048054)
	58                          # POP_EAX                     ; Get the number of arguments
	5B                          # POP_EBX                     ; Get the program name
	5B                          # POP_EBX                     ; Get the actual input name
	31C9                        # XOR_ECX_ECX                 ; prepare read_only, ecx = 0
	31D2                        # XOR_EDX_EDX %0              ; Extra sure, edx = 0
	6A05                        # PUSH_5                      ; prepare to set eax to 5
	58                          # POP_EAX                     ; the syscall number for open()
	CD80                        # INT_80                      ; Now open that damn file
	A3 1F810408                 # STORE32_Absolute32_eax &fin ; Preserve the file pointer we were given

	5B                          # POP_EBX                     ; Get the actual output name
	B9 41020000                 # LOADI32_ECX %577            ; Prepare file as O_WRONLY|O_CREAT|O_TRUNC
	BA C0010000                 # LOADI32_EDX %448            ; Prepare file as RWX for owner only (700 in octal)
	6A05                        # PUSH_5                      ; prepare to set eax to 5
	58                          # POP_EAX                     ; the syscall number for open()
	CD80                        # INT_80                      ; Now open that damn file
	A3 23810408                 # STORE32_Absolute32_eax &fout ; Preserve the file pointer we were given

	; Our flag for byte processing
	6AFF                        # PUSH_-1
	5D                          # POP_EBP                     ; ebp = -1

	; temp storage for the sum
	31FF                        # XOR_EDI_EDI                 ; edi = 0

#:loop ; (0x804807F)
	; Read a byte
	E8 84000000                 # CALL %Read_byte

	; process byte
	E8 1D000000                 # CALL %hex

	; Deal with -1 values
	85C0                        # TEST
	7C F2                       # JL8 !loop

	; deal with toggle
	85ED                        # TEST_EBP_EBP                ; jump if ebp >= 0
	7D 06                       # JGE8 !print

	; process first byte of pair
	89C7                        # COPY_EAX_to_EDI
	31ED                        # XOR_EBP_EBP                 ; ebp = 0
	EB E8                       # JMP8 !loop

; process second byte of pair
#:print ; (0x8048097)
	; update the sum and store in output
	C1E7 04                     # SHLI8_EDI !4
	01F8                        # ADD_EDI_to_EAX

	; flip the toggle
	6AFF                        # PUSH_-1
	5D                          # POP_EBP                     ; ebp = -1
	E8 51000000                 # CALL %write_byte

	EB D9                       # JMP8 !loop

#:hex ; (0x80480A6)
	; Purge Comment Lines (#)
	83F8 23                     # CMPI8_EAX !35
	74 25                       # JE8 !purge_comment

	; Purge Comment Lines (;)
	83F8 3B                     # CMPI8_EAX !59
	74 20                       # JE8 !purge_comment

	; deal all ascii less than 0
	83F8 30                     # CMPI8_EAX !48
	7C 35                       # JL8 !ascii_other

	; deal with 0-9
	83F8 3A                     # CMPI8_EAX !58
	7C 24                       # JL8 !ascii_num

	; deal with all ascii less than A
	83F8 41                     # CMPI8_EAX !65
	7C 2B                       # JL8 !ascii_other

	; deal with A-F
	83F8 47                     # CMPI8_EAX !71
	7C 22                       # JL8 !ascii_high

	;deal with all ascii less than a
	83F8 61                     # CMPI8_EAX !97
	7C 21                       # JL8 !ascii_other

	;deal with a-f
	83F8 67                     # CMPI8_EAX !103
	7C 14                       # JL8 !ascii_low

	; The rest that remains needs to be ignored
	EB 1A                       # JMP8 !ascii_other

#:purge_comment ; (0x80480D0)
	; Read a byte
	E8 33000000                 # CALL %Read_byte

	; Loop if not LF
	83F8 0A                     # CMPI8_EAX !10
	75 F6                       # JNE8 !purge_comment

	; Otherwise return -1
	6AFF                        # PUSH_-1
	58                          # POP_EAX                     ; eax = -1
	C3                          # RET

#:ascii_num ; (0x80480DE)
	83E8 30                     # SUBI8_EAX !48
	C3                          # RET

#:ascii_low ; (0x80480E2)
	83E8 57                     # SUBI8_EAX !87
	C3                          # RET

#:ascii_high ; (0x80480E6)
	83E8 37                     # SUBI8_EAX !55
	C3                          # RET

#:ascii_other ; (0x80480EA)
	6AFF                        # PUSH_-1
	58                          # POP_EAX                     ; eax = -1
	C3                          # RET

#:Done ; (0x80480EE)
	; program completed Successfully
	31DB                        # XOR_EBX_EBX                 ; All is well, ebx = 0
	6A01                        # PUSH_1
	58                          # POP_EAX                     ; put the exit syscall number in eax
	CD80                        # INT_80                      ; Call it a good day

; Writes byte stored in al
#:write_byte ; (0x80480F5)
	; Print our Hex
	6A01                        # PUSH_1                      ; prepare to set edx to 1
	5A                          # POP_EDX                     ; set the size of chars we want
	50                          # PUSH_EAX                    ; Move output to stack
	89E1                        # COPY_ESP_to_ECX             ; What we are writing
	8B1D 23810408               # LOAD32_Absolute32_ebx &fout ; Where are we writing to
	6A04                        # PUSH_4                      ; prepare to set eax to 4
	58                          # POP_EAX                     ; the syscall number for write
	CD80                        # INT_80                      ; call the Kernel
	5B                          # POP_EBX                     ; deallocate stack
	C3                          # RET

#:Read_byte ; (0x8048108)
	; Attempt to read 1 byte from Input file
	6A01                        # PUSH_1                      ; prepare to set edx to 1
	5A                          # POP_EDX                     ; set the size of chars we want
	53                          # PUSH_EBX                    ; allocate stack
	89E1                        # COPY_ESP_to_ECX             ; Where to put it
	8B1D 1F810408               # LOAD32_Absolute32_ebx &fin  ; Where are we reading from
	6A03                        # PUSH_3                      ; prepare to set eax to 3
	58                          # POP_EAX                     ; the syscall number for read
	CD80                        # INT_80                      ; call the Kernel

	85C0                        # TEST                        ; check what we got
	74 D1                       # JE8 !Done                   ; Got EOF call it done

	; load byte
	58                          # POP_EAX                     ; load char
	C3                          # RET

#:fin ; (0x804811F)
	00000000                    # NULL
#:fout ; (0x8048123)
	00000000                    # NULL
#:ELF_end
